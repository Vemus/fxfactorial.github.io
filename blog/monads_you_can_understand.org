#+TITLE:       Let's just use Monads
#+AUTHOR:      Edgar Aroutiounian
#+EMAIL:       edgar.factorial@gmail.com
#+DATE:        2015-09-23 Wed
#+URI:         /blog/%y/%m/%d/let's-just-use-monads
#+KEYWORDS:    monads
#+TAGS:        ocaml, functional programming
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: Pragmatic Monads

Let's learn about monads as programmers, that is let's use them for
building something and in the process we'll build up a intuition;
practice first, then we can come back to theory.

(I'll be writing to an OCaml audience mainly, but the Monad idea
should be understandable anyway)

As Bryan O'Sullivan said (From Real World Haskell) "...we need
something that's non-trivial but still chewey." So we'll build a real
working example in OCaml that will be the starting point of a library
to the [[https://stripe.com/docs/api][Stripe API]] and it will use monads.

* Prereqs
We need to make sure we have all the same starting point for this
code, I assume you have [[https://opam.ocaml.org][opam]] installed. Now do:
#+BEGIN_SRC shell
$ opam install lwt.unix cohttp.lwt yojson uri
#+END_SRC
These are the libaries we will use: ~lwt~ is for threading,
~cohttp.lwt~ is for our HTTP requests, ~uri~ for handling URIs and
~yojson~, an easy to use and *de facto* json library.

* Stripe
The Stripe API is a straight forward REST API. You'll need to have a
developer account from which you'll get your Test Key, hence forth
known as ~key~. We'll focus on one task, we'll start the process of
charging a credit card. Point your browser to this [[https://stripe.com/docs/api#create_charge][link]] which shows
how to create the "Charge" object. From there we see we need to do a
~POST~ to https://api.stripe.com/v1/charges with several required
arguments:

1) The amount to charge
2) The ISO code for currency (a perfect use-case for a variant, we'll
   use polymorphic variants for this)
3) Either the Customer or Source, (this will also use polymorphic
   variants)
   
All of Stripe's API returns JSON, so we can already sketch out our
function's signature and helper data structure, something like:
#+BEGIN_SRC ocaml
type t = { authed : Cohttp.Headers.t; 
           end_point : string; }

val make_handle : unit -> t

val create_charge : int -> 
                    string -> 
                    string ->
                    t ->  
                    Yojson.Basic.json Lwt.t
#+END_SRC
Mostly straight forward, although that ~Lwt.t~ should look at
little strange. The quick answer that that ~create_charge~ will give
back an ~Lwt.t~ Monad which in this case will contain a ~json~ object.

Let's start filling out the ~make_handle~ function, 
#+BEGIN_SRC ocaml
let make_handle () = 
  let auth_me k = 
    let starter = Cohttp.Header.init () in 
    Cohttp.Auth.credential_of_string ("Bearer " ^ k)
    |> Cohttp.Header.add_authorization starter
  in
  {authed = auth_me "YOUR STRIPE KEY"; 
   (** Hardcoding to the charge create path *)
   end_point = "https://api.stripe.com/v1/charges"}
#+END_SRC
This creates our record needed for making a post. Stripe requires a
key in each request so we'll make this record to encapsulate that,
otherwise we have to write boilerplate code, never fun.

Now the first cut of out ~create_charge~ function:

(*META NOTE* This is horrible indentation, I'm only doing it because
of the sizing done in the exporting of this document and I want it to
be clear what's happening and the coloring is wrong because ~'~ can be
used in a value's name but its messing up the coding exporter)
#+BEGIN_SRC ocaml -n
let create_charge amount currency source handle = 
  let open Cohttp_lwt_unix in
  let this_uri = Uri.of_string handle.end_point in
  [("amount", string_of_int amount);
   ("currency", currency);]
   ("source", source)]
  |> Uri.add_query_params' this_uri
  |> Client.post ~headers:handle.authed >>= 
     fun (resp, body) -> 
     Cohttp_lwt_body.to_string body >|= 
     Yojson.Basic.from_string
#+END_SRC
Okay, so what the hell is going on. Line 2 open the ~Cohttp_lwt_unix~
module locally to this function so that we can type ~Client.post~
instead of ~Cohttp_lwt_unix.Client.post~. Line 3 creates a ~uri~
object, lines 4-6 are the query parameters we want to add to our ~uri~
object. The ~|>~ symbol is a function, you can call it reverse apply,
you can define it as
#+BEGIN_SRC ocaml 
let ( |> ) f x = x f
#+END_SRC
but you don't need to, it comes with OCaml. It just says take the left
side as the input to the right side, aka a Unix Pipe. Now let's see
the signature of ~Client.post~, its:
#+BEGIN_SRC ocaml
val post ?ctx:Cohttp_lwt_unix.Client.ctx ->
         ?body:Cohttp_lwt_body.t ->
         ?chunked:bool ->
         ?headers:Cohttp.Header.t ->
         Uri.t -> 
         (Cohttp.Response.t * Cohttp_lwt_body.t) Lwt.t
#+END_SRC
Looks big but we don't care about most of it, in fact we could just
care about the ~Uri.t~ parameter since the rest of the parameters, the
ones with ~?~, have default values.

* Moral of the Story
So in terms of actually day to day coding, you don't actually need to
know what a Monad "is", you just need to know how to use it and
honestly that's completely fine.
