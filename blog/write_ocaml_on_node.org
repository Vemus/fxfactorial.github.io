#+TITLE:       Compile OCaml to JavaScript, run on Node
#+AUTHOR:      Edgar Aroutiounian
#+EMAIL:       edgar.factorial@gmail.com
#+DATE:        2015-11-05 Thu
#+URI:         /blog/%y/%m/%d/write-ocaml,-run-on-nodejs
#+KEYWORDS:    nodejs, javascript, OCaml
#+TAGS:        nodejs, JavaScript, OCaml
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: OCaml on Node

I've been exposed to Node, its an amazing ecosystem with great cross
platform support and a great standard library; my only issue is
*JavaScript*. So I've been writing several libraries, bindings, that
compile OCaml to JavaScript which I then run on ~node~.

* Sample Code
Here are some working examples, many are directly from the README at
[[https://github.com/fxfactorial/ocaml-nodejs/blob/master/README.md][ocaml-nodejs]].

*Multicast DNS over UDP sockets, only for the local network, like a
 no config p2p chat application.*
#+BEGIN_SRC ocaml -n
open Nodejs

module U = Yojson.Basic.Util

let (multicast_addr, bind_addr, port) = "224.1.1.1", "0.0.0.0", 6811

let () =
  Random.self_init ();
  let p = new process in
  let user_name = ref (Printf.sprintf "User:%d" (Random.int 10000)) in
  let listener = Udp_datagram.(create_socket ~reuse_address:true Udp4) in
  let sender = Udp_datagram.(create_socket ~reuse_address:true Udp4) in

  listener#bind ~port ~address:multicast_addr ~f:begin fun () ->
    listener#add_membership multicast_addr;
    listener#set_broadcast true;
    listener#set_multicast_loopback true
  end ();


  listener#on_message begin fun b resp ->

    let handle = b#to_string () |> json_of_string in
    if (handle <!> "id" |> Js.to_string) <> !user_name
    then print_string (handle <!> "message" |> Js.to_string)

  end;

  p#stdin#on_data begin function
    | String _ -> ()
    | Buffer b ->
      let msg = b#to_string () in
      (* This needs to be redone with Re_pcre *)
      if String.length msg > 10 then begin
        let modify = String.sub msg 0 9 in
        if modify = "set name:"
        then begin
          let as_string = Js.string (String.trim msg) in
          let chopped =
            as_string##split (Js.string ":") |> to_string_list |> Array.of_list
          in
          user_name := chopped.(1)
        end
      end;

      let msg = Printf.sprintf "%s>>>%s" !user_name (b#to_string ()) in
      let total_message = (object%js
        val id = !user_name |> to_js_str
        val message = msg |> to_js_str
        end) |> stringify
      in
      sender#send
        ~offset:0
        ~length:(String.length total_message)
        ~port
        ~dest_address:multicast_addr
        (String total_message)
    end
#+END_SRC

*Create a site and render directly from jade templates*
#+BEGIN_SRC ocaml
open Nodejs

let () =
  let exp = new Express.express in
  let app = new Express.app ~existing:None in

  app#set_app_value (`View_engine "jade");
  app#use (exp#static ".");
  app#get ~path:"/" (fun _ res -> res#render "index.jade");

  app#listen ~port:8080
#+END_SRC

*Create a raw server from the Net module*
#+BEGIN_SRC ocaml
let () =
  let server = Net.create_server ~conn_listener:begin fun sock ->
      sock#on_end (fun () -> print_endline "client disconnected");
      sock#write "Hello\r\n";
      sock >|> sock |> ignore
    end ()
  in
  server#listen ~port:8124 begin fun () ->
    let info = server#address in
    print_endline info.Net.address;
    print_endline (info.Net.ip_family |> string_of_ip);
    print_endline (info.Net.port |> string_of_int);
    print_endline "started server"
  end
#+END_SRC

*Create a file stream, gzip it, write it*
#+BEGIN_SRC ocaml -n
open Nodejs

let _ =
  Fs.create_read_stream "code.ml" >|>
  Zlib.create_gzip () >|>
  Fs.create_write_stream "NEWCODE_TEST.ml"
#+END_SRC


*Typed Decoding of Buffers*
#+BEGIN_SRC ocaml
open Nodejs

let () =
  let string_decoder = new String_decoder.decoder Utf_8 in
  let cent = new Buffer.buffer (`Array [|0xE2; 0x82; 0xAC|]) in
  (string_decoder#write cent) |> print_endline
#+END_SRC


This one is a bit more low level as it its a general idea of how these
bindings are implemented.

#+BEGIN_SRC ocaml -n
(* Assume this file is called c.ml *)
open Nodejs

class child_process = object

  val raw_js = require_module "child_process"

  (* Clearly not finished *)
  method spawn_sync cmd args : (string * string) list =
    let handle =
      [|i (Js.string cmd);
        i (List.map Js.string args |> Array.of_list |> Js.array)|]
      |> m raw_js "spawnSync"
    in
    (handle <!> "envPairs")
    |> Js.to_array |> Array.map begin fun (s : Js.js_string Js.t) ->
      let chop = s##split (Js.string "=") |> to_string_list |> Array.of_list in
      (chop.(0), chop.(1))
    end
    |> Array.to_list

end

let () =
  let ls_proc = (new child_process)#spawn_sync "ls" [] in
  ls_proc |> List.iter begin fun (key, value) ->
    Printf.sprintf "Key was: %s and value: %s" key value
    |> print_endline
  end
#+END_SRC

(Line one comes from my ~nodejs~ package, install it with ~opam install
nodejs~). 

This example is a subset of my bindings to the builtin node module,
[[https://nodejs.org/api/child_process.html][child_process]]. Here we spawn a separate process and create an OCaml
~alist~ out of the environment variables of the spawned process. A
point of interest is the poverty of OCaml StdLib's ~String~ module, so
much so that I get more functionality out of JavaScript's string
methods! (There's no split in the StdLib). 

To actually run this code you'll need to do:

#+BEGIN_SRC shell
$ ocamlfind ocamlc c.ml -linkpkg -package nodejs -o T.out
$ js_of_ocaml T.out
$ node T.js
#+END_SRC

* Projects
This approach surprisingly works and I've written similar bindings to
[[https://github.com/fxfactorial/ocaml-npm-socket-io][socket.io]] for which I have a working chat server:

#+BEGIN_SRC ocaml
open Nodejs

let () =
  let io = Socket_io.require () in
  let server =
    Http.create_server begin fun incoming response ->

      Fs.read_file ~path:"./client.html" begin fun err data ->
        response#write_head ~status_code:200 [("Content-type", "text/html")];
        response#end_ ~data:(Http.String data) ()

      end
    end
  in
  let app = server#listen ~port:8080 begin fun () ->
      Printf.sprintf
        "Started Server and Running node: %s" (new process#version)
      |> print_endline
    end
  in

  let io = io#listen app in
  io#sockets#on_connection begin fun socket ->

    socket#on "message_to_server" begin fun data ->

      io#sockets#emit
        ~event_name:"message_to_client"
        !!(object%js val message = data <!> "message" end)

    end
  end
#+END_SRC
Notice the features of OCaml that don't exist in JavaScript at all,
like named parameters.

Another project in this vein are my bindings to Github's ~Electron~
project, here's a project I did with a friend using Basecamp's
recently released ~Trix~ editor.

[[./electron_working.gif]]

* Like what you see?
Writing out these bindings is a bit of work, Node's API is pretty big
in addition to third party code like socket.io, express, and
Electron. Much of these bindings are quite formulaic, although some
ideas don't easily match up between the OCaml and JavaScript boundary,
like ~varargs~ so that requires some more thought at times. 

To any reader interested in OCaml open-source or for whatever reason,
send me a PR, its mostly an issue of translating [[https://nodejs.org/api/index.html][the Node API]] into the
equivalent bindings:

[[https://github.com/fxfactorial/ocaml-nodejs][nodejs repo]]

[[https://github.com/fxfactorial/ocaml-electron][electron repo]]
